# FansTrade å®Œæ•´æµç¨‹å®æ–½è®¡åˆ’

> åŸºäº Binance.com çš„ç”¨æˆ·æ³¨å†Œ â†’ è·Ÿä¹° â†’ äº¤æ˜“å®Œæ•´è·¯å¾„
> åˆ›å»ºæ—¶é—´: 2025-01-14

## ä¸šåŠ¡æµç¨‹æ¦‚è§ˆ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    å®Œæ•´ä¸šåŠ¡æµç¨‹å›¾                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

1. ç”¨æˆ·æ³¨å†Œé˜¶æ®µ
   â”œâ”€ ç”¨æˆ·åœ¨ FansTrade æ³¨å†Œè´¦æˆ·
   â”œâ”€ éªŒè¯é‚®ç®±å’Œè®¾ç½®å¯†ç 
   â””â”€ è¿›å…¥ Dashboard

2. ç»‘å®š Binance é˜¶æ®µ
   â”œâ”€ ç”¨æˆ·å‰å¾€ Binance.com åˆ›å»º API Key
   â”œâ”€ åœ¨ FansTrade è¾“å…¥ API Key + Secret
   â”œâ”€ ç³»ç»ŸéªŒè¯ API Key æœ‰æ•ˆæ€§ï¼ˆè°ƒç”¨ Binance accountInfoï¼‰
   â”œâ”€ åŠ å¯†å­˜å‚¨åˆ°æ•°æ®åº“
   â””â”€ æ˜¾ç¤ºè´¦æˆ·ä½™é¢å’ŒæŒä»“

3. å…³æ³¨äº¤æ˜“å‘˜é˜¶æ®µ
   â”œâ”€ æµè§ˆäº¤æ˜“å‘˜åˆ—è¡¨ï¼ˆæŒ‰èƒœç‡/æ”¶ç›Šæ’åºï¼‰
   â”œâ”€ æŸ¥çœ‹äº¤æ˜“å‘˜è¯¦æƒ…ï¼ˆå†å²ä¿¡å·ã€èƒœç‡ã€é£æ ¼ï¼‰
   â”œâ”€ ç‚¹å‡»å…³æ³¨æŒ‰é’®
   â””â”€ è®¾ç½®è·Ÿå•é…ç½®ï¼ˆè‡ªåŠ¨/æ‰‹åŠ¨ã€æœ€å¤§é‡‘é¢ã€äº¤æ˜“å¯¹è¿‡æ»¤ï¼‰

4. äº¤æ˜“ä¿¡å·ç”Ÿæˆé˜¶æ®µï¼ˆç³»ç»Ÿè‡ªåŠ¨ï¼‰
   â”œâ”€ å®šæ—¶ä»»åŠ¡æ¯ 5 åˆ†é’Ÿæ‰«æå¸‚åœº
   â”œâ”€ è®¡ç®—æŠ€æœ¯æŒ‡æ ‡ï¼ˆMACD, RSI, Bollinger Bandsï¼‰
   â”œâ”€ ç”Ÿæˆäº¤æ˜“ä¿¡å·ï¼ˆBUY/SELL/HOLD + ç½®ä¿¡åº¦ï¼‰
   â”œâ”€ ä¿å­˜åˆ°æ•°æ®åº“ï¼ˆbinance_trading_signalsï¼‰
   â””â”€ WebSocket æ¨é€ç»™å…³æ³¨è€…

5. è·Ÿå•æ‰§è¡Œé˜¶æ®µ
   â”œâ”€ å…³æ³¨è€…æ”¶åˆ°ä¿¡å·æ¨é€
   â”œâ”€ è‡ªåŠ¨æ¨¡å¼ï¼šç³»ç»Ÿè‡ªåŠ¨æ‰§è¡Œï¼ˆå¸¦é£æ§æ£€æŸ¥ï¼‰
   â”‚  â”œâ”€ æ£€æŸ¥è´¦æˆ·ä½™é¢
   â”‚  â”œâ”€ æ£€æŸ¥å•ç¬”é™é¢
   â”‚  â”œâ”€ è°ƒç”¨ Binance API ä¸‹å•
   â”‚  â””â”€ è®°å½•äº¤æ˜“ç»“æœ
   â””â”€ æ‰‹åŠ¨æ¨¡å¼ï¼šç”¨æˆ·ç¡®è®¤åæ‰§è¡Œ

6. äº¤æ˜“è®°å½•å’Œç»Ÿè®¡é˜¶æ®µ
   â”œâ”€ æ˜¾ç¤ºå®æ—¶æŒä»“
   â”œâ”€ æ˜¾ç¤ºå†å²äº¤æ˜“è®°å½•
   â”œâ”€ è®¡ç®—ç›ˆäºç»Ÿè®¡
   â””â”€ ç”Ÿæˆäº¤æ˜“æŠ¥å‘Š
```

---

## Phase 2: Binance API å°è£…ï¼ˆ6-8 å°æ—¶ï¼‰

### ç›®æ ‡
å®ç°å®Œæ•´çš„ Binance REST API å’Œ WebSocket å°è£…ï¼Œæ”¯æŒå¸‚åœºæ•°æ®ã€è´¦æˆ·æŸ¥è¯¢ã€ä¸‹å•åŠŸèƒ½ã€‚

### Task 2.1: Binance Service æ ¸å¿ƒå°è£…

**æ–‡ä»¶**: `src/services/binance/binance.service.ts`

**åŠŸèƒ½æ¸…å•**:
1. âœ… å…¬å…±å®¢æˆ·ç«¯ï¼ˆæ— éœ€ API Keyï¼‰
   - è·å–å®æ—¶ä»·æ ¼
   - è·å– K çº¿æ•°æ®
   - è·å–äº¤æ˜“å¯¹ä¿¡æ¯

2. âœ… ç§æœ‰å®¢æˆ·ç«¯ï¼ˆéœ€è¦ç”¨æˆ· API Keyï¼‰
   - è§£å¯†ç”¨æˆ· API Key
   - åˆ›å»ºæˆæƒå®¢æˆ·ç«¯
   - å®¢æˆ·ç«¯ç¼“å­˜ç®¡ç†

3. âœ… è´¦æˆ·åŠŸèƒ½
   - æŸ¥è¯¢è´¦æˆ·ä½™é¢
   - æŸ¥è¯¢å†å²è®¢å•
   - æŸ¥è¯¢å½“å‰æŒ‚å•

4. âœ… äº¤æ˜“åŠŸèƒ½
   - å¸‚ä»·å•ä¸‹å•
   - é™ä»·å•ä¸‹å•
   - å–æ¶ˆè®¢å•

5. âœ… Redis ç¼“å­˜å±‚
   - ä»·æ ¼ç¼“å­˜ï¼ˆ5 ç§’ TTLï¼‰
   - K çº¿ç¼“å­˜ï¼ˆ60 ç§’ TTLï¼‰
   - äº¤æ˜“å¯¹ä¿¡æ¯ç¼“å­˜ï¼ˆ1 å°æ—¶ TTLï¼‰

**ä»£ç ç»“æ„**:
```typescript
export class BinanceService {
  // å…¬å…± API
  getPublicClient(): MainClient
  getCurrentPrice(symbol: string): Promise<number>
  getKlines(symbol: string, interval: string, limit?: number): Promise<Kline[]>
  getExchangeInfo(): Promise<ExchangeInfo>

  // ç§æœ‰ API
  getPrivateClient(userId: string): Promise<MainClient>
  getAccountBalance(userId: string): Promise<Balance[]>
  getAccountInfo(userId: string): Promise<AccountInfo>
  getOpenOrders(userId: string, symbol?: string): Promise<Order[]>

  // äº¤æ˜“ API
  placeMarketOrder(userId: string, params: MarketOrderParams): Promise<OrderResult>
  placeLimitOrder(userId: string, params: LimitOrderParams): Promise<OrderResult>
  cancelOrder(userId: string, symbol: string, orderId: string): Promise<boolean>

  // è¾…åŠ©åŠŸèƒ½
  syncTradingPairs(): Promise<void>  // åŒæ­¥æ‰€æœ‰äº¤æ˜“å¯¹åˆ°æ•°æ®åº“
  validateApiKey(apiKey: string, apiSecret: string): Promise<boolean>
}
```

**éªŒæ”¶æ ‡å‡†**:
- [ ] è·å– BTC/USDT å®æ—¶ä»·æ ¼æˆåŠŸ
- [ ] è·å– BTC/USDT 1å°æ—¶ Kçº¿æˆåŠŸ
- [ ] ä½¿ç”¨æµ‹è¯• API Key æŸ¥è¯¢ä½™é¢æˆåŠŸ
- [ ] Redis ç¼“å­˜å‘½ä¸­ç‡ > 80%
- [ ] å•å…ƒæµ‹è¯•è¦†ç›–ç‡ > 80%

---

### Task 2.2: Binance WebSocket å®æ—¶æ¨é€æœåŠ¡

**æ–‡ä»¶**: `src/services/binance/websocket.service.ts`

**åŠŸèƒ½æ¸…å•**:
1. âœ… ä»·æ ¼æ¨é€
   - è®¢é˜…å¤šä¸ªäº¤æ˜“å¯¹å®æ—¶ä»·æ ¼
   - è§£æ ticker æ•°æ®
   - å¹¿æ’­ç»™å‰ç«¯

2. âœ… K çº¿æ¨é€
   - è®¢é˜… 1åˆ†é’Ÿ/5åˆ†é’Ÿ/1å°æ—¶ Kçº¿
   - å®æ—¶æ›´æ–°å›¾è¡¨

3. âœ… ç”¨æˆ·æ•°æ®æµ
   - è®¢é˜…è®¢å•æ›´æ–°
   - è®¢é˜…è´¦æˆ·ä½™é¢å˜åŒ–

4. âœ… è¿æ¥æ± ç®¡ç†
   - å¤ç”¨ WebSocket è¿æ¥
   - è‡ªåŠ¨é‡è¿æœºåˆ¶
   - å¿ƒè·³æ£€æµ‹

**ä»£ç ç»“æ„**:
```typescript
export class BinanceWebSocketService extends EventEmitter {
  // å¸‚åœºæ•°æ®æµ
  subscribePriceTicker(symbols: string[]): void
  subscribeKline(symbol: string, interval: string): void
  subscribeDepth(symbol: string): void

  // ç”¨æˆ·æ•°æ®æµ
  subscribeUserDataStream(userId: string): void

  // è¿æ¥ç®¡ç†
  getConnection(streamName: string): WebSocket
  closeConnection(streamName: string): void
  closeAll(): void

  // äº‹ä»¶ç›‘å¬
  on('price', (data: PriceTickerData) => void)
  on('kline', (data: KlineData) => void)
  on('order', (data: OrderUpdateData) => void)
  on('balance', (data: BalanceUpdateData) => void)
}
```

**éªŒæ”¶æ ‡å‡†**:
- [ ] å®æ—¶ä»·æ ¼æ¨é€å»¶è¿Ÿ < 100ms
- [ ] WebSocket è¿æ¥ç¨³å®šè¿è¡Œ > 1å°æ—¶
- [ ] è‡ªåŠ¨é‡è¿æµ‹è¯•é€šè¿‡
- [ ] åŒæ—¶è®¢é˜… 10 ä¸ªäº¤æ˜“å¯¹æ— å‹åŠ›

---

### Task 2.3: ç”¨æˆ·ç»‘å®š Binance API Key æµç¨‹

**åç«¯ API**: `POST /api/binance/bind-api-key`

**å‰ç«¯é¡µé¢**: `/app/settings/binance/page.tsx`

**ä¸šåŠ¡æµç¨‹**:
```
1. ç”¨æˆ·è¾“å…¥ API Key + Secret
2. å‰ç«¯è°ƒç”¨ POST /api/binance/bind-api-key
3. åç«¯éªŒè¯ API Key æœ‰æ•ˆæ€§
   - è°ƒç”¨ Binance accountInfo()
   - æ£€æŸ¥æƒé™ï¼ˆå¿…é¡»æœ‰ spot æƒé™ï¼‰
4. åŠ å¯†å­˜å‚¨åˆ°æ•°æ®åº“
5. è¿”å›æˆåŠŸ + è´¦æˆ·ä½™é¢
6. å‰ç«¯æ˜¾ç¤ºç»‘å®šæˆåŠŸæç¤º
```

**å®‰å…¨æªæ–½**:
- API Secret åŠ å¯†å­˜å‚¨ï¼ˆAES-256-GCMï¼‰
- æ°¸ä¸åœ¨æ—¥å¿—ä¸­è®°å½•æ˜æ–‡ API Key
- æ”¯æŒ IP ç™½åå•ï¼ˆå¯é€‰ï¼‰
- æ”¯æŒåªè¯»æ¨¡å¼ï¼ˆåªæŸ¥è¯¢ï¼Œä¸äº¤æ˜“ï¼‰

**å‰ç«¯ UI**:
```typescript
// ç»‘å®š API Key è¡¨å•
<Card>
  <CardHeader>
    <CardTitle>ç»‘å®š Binance è´¦æˆ·</CardTitle>
    <CardDescription>
      å‰å¾€ <a href="https://www.binance.com/en/my/settings/api-management">Binance API ç®¡ç†</a> åˆ›å»º API Key
    </CardDescription>
  </CardHeader>
  <CardContent>
    <Form>
      <Input label="API Key" placeholder="è¾“å…¥ Binance API Key" />
      <Input label="API Secret" type="password" placeholder="è¾“å…¥ API Secret" />
      <Input label="æ ‡ç­¾ï¼ˆå¯é€‰ï¼‰" placeholder="ä¸»è´¦æˆ·" />
      <Checkbox label="å¯ç”¨ç°è´§äº¤æ˜“" checked />
      <Button type="submit">éªŒè¯å¹¶ç»‘å®š</Button>
    </Form>
  </CardContent>
</Card>

// å·²ç»‘å®šè´¦æˆ·åˆ—è¡¨
<Card>
  <CardHeader>
    <CardTitle>æˆ‘çš„ Binance è´¦æˆ·</CardTitle>
  </CardHeader>
  <CardContent>
    <AccountCard>
      <Badge>ä¸»è´¦æˆ·</Badge>
      <div>ä½™é¢: 1,234.56 USDT</div>
      <div>ç»‘å®šæ—¶é—´: 2025-01-14</div>
      <Button variant="outline">è§£ç»‘</Button>
    </AccountCard>
  </CardContent>
</Card>
```

**éªŒæ”¶æ ‡å‡†**:
- [ ] è¾“å…¥æœ‰æ•ˆ API Key ç»‘å®šæˆåŠŸ
- [ ] è¾“å…¥æ— æ•ˆ API Key æç¤ºé”™è¯¯
- [ ] æ•°æ®åº“åŠ å¯†å­˜å‚¨éªŒè¯é€šè¿‡
- [ ] ç»‘å®šåæ˜¾ç¤ºè´¦æˆ·ä½™é¢
- [ ] å¯ä»¥è§£ç»‘ API Key

---

### Task 2.4: äº¤æ˜“å¯¹åŒæ­¥å’Œå¸‚åœºæ•°æ®æ¥å£

**API è·¯ç”±**:
```typescript
// è·å–æ‰€æœ‰äº¤æ˜“å¯¹åˆ—è¡¨
GET /api/binance/pairs
Response: { pairs: TradingPair[] }

// è·å–å•ä¸ªäº¤æ˜“å¯¹è¯¦æƒ…
GET /api/binance/pairs/:symbol
Response: { pair: TradingPair, price: number, volume24h: number }

// è·å–å®æ—¶ä»·æ ¼
GET /api/binance/price/:symbol
Response: { symbol: string, price: number, timestamp: number }

// è·å– K çº¿æ•°æ®
GET /api/binance/klines/:symbol?interval=1h&limit=100
Response: { symbol: string, klines: Kline[] }

// è·å–è´¦æˆ·ä½™é¢
GET /api/binance/balance
Response: { balances: Balance[] }
```

**å®šæ—¶ä»»åŠ¡**: æ¯å°æ—¶åŒæ­¥äº¤æ˜“å¯¹ä¿¡æ¯
```typescript
// src/jobs/sync-trading-pairs.job.ts
cron.schedule('0 * * * *', async () => {
  const exchangeInfo = await binanceService.getExchangeInfo();

  for (const symbol of exchangeInfo.symbols) {
    await prisma.tradingPair.upsert({
      where: { symbol: symbol.symbol },
      update: {
        status: symbol.status,
        minPrice: symbol.filters.PRICE_FILTER.minPrice,
        maxPrice: symbol.filters.PRICE_FILTER.maxPrice,
        // ...
        lastSyncAt: new Date(),
      },
      create: {
        symbol: symbol.symbol,
        baseAsset: symbol.baseAsset,
        quoteAsset: symbol.quoteAsset,
        // ...
      }
    });
  }

  console.log(`âœ… Synced ${exchangeInfo.symbols.length} trading pairs`);
});
```

**éªŒæ”¶æ ‡å‡†**:
- [ ] äº¤æ˜“å¯¹åŒæ­¥ä»»åŠ¡æ­£å¸¸è¿è¡Œ
- [ ] æ•°æ®åº“å­˜å‚¨ > 500 ä¸ªäº¤æ˜“å¯¹
- [ ] å®æ—¶ä»·æ ¼ API å“åº” < 50ms
- [ ] K çº¿æ•°æ®æ ¼å¼æ­£ç¡®

---

## Phase 3: äº¤æ˜“ä¿¡å·ç”Ÿæˆå¼•æ“ï¼ˆ8-10 å°æ—¶ï¼‰

### Task 3.1: æŠ€æœ¯æŒ‡æ ‡è®¡ç®—å¼•æ“

**æ–‡ä»¶**: `src/services/trading-signals/indicators.service.ts`

**æ”¯æŒçš„æŒ‡æ ‡**:
1. MACDï¼ˆç§»åŠ¨å¹³å‡æ”¶æ•›æ•£åº¦ï¼‰
2. RSIï¼ˆç›¸å¯¹å¼ºå¼±æŒ‡æ•°ï¼‰
3. Bollinger Bandsï¼ˆå¸ƒæ—å¸¦ï¼‰
4. EMAï¼ˆæŒ‡æ•°ç§»åŠ¨å¹³å‡ï¼‰
5. SMAï¼ˆç®€å•ç§»åŠ¨å¹³å‡ï¼‰

**ä»£ç ç»“æ„**:
```typescript
export class IndicatorsService {
  async calculateMACD(symbol: string, interval: string): Promise<MACDResult> {
    const klines = await binanceService.getKlines(symbol, interval, 100);
    const closePrices = klines.map(k => k.close);

    const macd = new MACD({ shortInterval: 12, longInterval: 26, signalInterval: 9 });
    for (const price of closePrices) {
      macd.update(price);
    }

    return {
      macd: macd.getResult().macd,
      signal: macd.getResult().signal,
      histogram: macd.getResult().histogram,
      crossover: this.detectCrossover(macd),  // é‡‘å‰/æ­»å‰
    };
  }

  async calculateRSI(symbol: string, interval: string): Promise<RSIResult> {
    const klines = await binanceService.getKlines(symbol, interval, 100);
    const rsi = new RSI(14);

    for (const kline of klines) {
      rsi.update(kline.close);
    }

    const value = rsi.getResult();

    return {
      value,
      overbought: value > 70,     // è¶…ä¹°
      oversold: value < 30,        // è¶…å–
      signal: value < 30 ? 'BUY' : value > 70 ? 'SELL' : 'HOLD',
    };
  }

  async calculateBollingerBands(symbol: string, interval: string): Promise<BBResult> {
    const klines = await binanceService.getKlines(symbol, interval, 100);
    const bb = new BollingerBands(20, 2);

    for (const kline of klines) {
      bb.update(kline.close);
    }

    const result = bb.getResult();
    const currentPrice = klines[klines.length - 1].close;

    return {
      upper: result.upper,
      middle: result.middle,
      lower: result.lower,
      bandwidth: (result.upper - result.lower) / result.middle,
      signal: currentPrice < result.lower ? 'BUY' : currentPrice > result.upper ? 'SELL' : 'HOLD',
    };
  }

  // ç»¼åˆåˆ†æ
  async analyzeSymbol(symbol: string, interval: string = '1h'): Promise<SignalAnalysis> {
    const [macd, rsi, bb] = await Promise.all([
      this.calculateMACD(symbol, interval),
      this.calculateRSI(symbol, interval),
      this.calculateBollingerBands(symbol, interval),
    ]);

    // æŠ•ç¥¨æœºåˆ¶ï¼š3 ä¸ªæŒ‡æ ‡ä¸­è‡³å°‘ 2 ä¸ªåŒæ„æ‰å‘ä¿¡å·
    const signals = [macd.signal, rsi.signal, bb.signal];
    const buyVotes = signals.filter(s => s === 'BUY').length;
    const sellVotes = signals.filter(s => s === 'SELL').length;

    let finalSignal: 'BUY' | 'SELL' | 'HOLD' = 'HOLD';
    let confidence = 0;

    if (buyVotes >= 2) {
      finalSignal = 'BUY';
      confidence = buyVotes / 3;
    } else if (sellVotes >= 2) {
      finalSignal = 'SELL';
      confidence = sellVotes / 3;
    }

    return {
      symbol,
      interval,
      signal: finalSignal,
      confidence,
      indicators: { macd, rsi, bb },
      timestamp: new Date(),
    };
  }
}
```

**éªŒæ”¶æ ‡å‡†**:
- [ ] MACD è®¡ç®—å‡†ç¡®ï¼ˆä¸ TradingView å¯¹æ¯”è¯¯å·® < 1%ï¼‰
- [ ] RSI è®¡ç®—å‡†ç¡®
- [ ] Bollinger Bands è®¡ç®—å‡†ç¡®
- [ ] ç»¼åˆä¿¡å·ç½®ä¿¡åº¦åˆç†

---

### Task 3.2: äº¤æ˜“ä¿¡å·ç”Ÿæˆå’Œå­˜å‚¨

**æ–‡ä»¶**: `src/services/trading-signals/signal-generator.service.ts`

**ä¸šåŠ¡é€»è¾‘**:
```typescript
export class SignalGeneratorService {
  async generateSignal(
    symbol: string,
    interval: string,
    strategyId?: string
  ): Promise<BinanceTradingSignal> {
    // 1. åˆ†ææŠ€æœ¯æŒ‡æ ‡
    const analysis = await indicatorsService.analyzeSymbol(symbol, interval);

    // 2. åªæœ‰ç½®ä¿¡åº¦ > 0.6 æ‰ç”Ÿæˆä¿¡å·
    if (analysis.confidence < 0.6) {
      console.log(`âŒ ${symbol} signal confidence too low: ${analysis.confidence}`);
      return null;
    }

    // 3. è·å–å½“å‰ä»·æ ¼
    const currentPrice = await binanceService.getCurrentPrice(symbol);

    // 4. è·å–äº¤æ˜“å¯¹
    const tradingPair = await prisma.tradingPair.findUnique({
      where: { symbol }
    });

    if (!tradingPair) {
      throw new Error(`Trading pair ${symbol} not found`);
    }

    // 5. ä¿å­˜ä¿¡å·åˆ°æ•°æ®åº“
    const signal = await prisma.binanceTradingSignal.create({
      data: {
        symbol,
        signalType: analysis.signal,
        price: currentPrice.toString(),
        confidence: analysis.confidence,
        indicators: analysis.indicators,
        status: 'PENDING',
        tradingPairId: tradingPair.id,
        strategyId,
      }
    });

    console.log(`âœ… Generated ${analysis.signal} signal for ${symbol} @ ${currentPrice} (confidence: ${analysis.confidence})`);

    return signal;
  }

  async generateSignalsForWatchlist(symbols: string[]): Promise<BinanceTradingSignal[]> {
    const signals = [];

    for (const symbol of symbols) {
      try {
        const signal = await this.generateSignal(symbol, '1h');
        if (signal) {
          signals.push(signal);
        }
      } catch (error) {
        console.error(`Error generating signal for ${symbol}:`, error);
      }
    }

    return signals;
  }
}
```

**éªŒæ”¶æ ‡å‡†**:
- [ ] ä¿¡å·ç”ŸæˆæˆåŠŸå­˜å‚¨åˆ°æ•°æ®åº“
- [ ] ä¿¡å·åŒ…å«å®Œæ•´çš„æŒ‡æ ‡æ•°æ®
- [ ] ç½®ä¿¡åº¦è®¡ç®—åˆç†
- [ ] æ‰¹é‡ç”Ÿæˆä¿¡å·æ— é”™è¯¯

---

### Task 3.3: å®šæ—¶ä»»åŠ¡æ‰«æå’Œä¿¡å·æ¨é€

**æ–‡ä»¶**: `src/jobs/signal-scanner.job.ts`

**å®šæ—¶ä»»åŠ¡**:
```typescript
import cron from 'node-cron';
import { signalGeneratorService } from '../services/trading-signals/signal-generator.service';
import { io } from '../index';  // Socket.IO instance

// æ¯ 5 åˆ†é’Ÿæ‰«æä¸€æ¬¡çƒ­é—¨äº¤æ˜“å¯¹
cron.schedule('*/5 * * * *', async () => {
  console.log('ğŸ” [Signal Scanner] Starting scan...');

  // è·å–æ‰€æœ‰æ´»è·ƒçš„ç›‘æ§äº¤æ˜“å¯¹
  const watchlist = ['BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'SOLUSDT', 'ADAUSDT'];

  const signals = await signalGeneratorService.generateSignalsForWatchlist(watchlist);

  console.log(`âœ… [Signal Scanner] Generated ${signals.length} signals`);

  // æ¨é€ç»™æ‰€æœ‰åœ¨çº¿ç”¨æˆ·
  for (const signal of signals) {
    // æŸ¥æ‰¾å…³æ³¨äº†ç›¸å…³ç­–ç•¥çš„ç”¨æˆ·
    const followers = await prisma.follow.findMany({
      where: {
        trader: {
          strategies: {
            some: {
              binanceSignals: {
                some: { id: signal.id }
              }
            }
          }
        }
      },
      include: { follower: true }
    });

    // WebSocket æ¨é€
    for (const follow of followers) {
      io.to(`user_${follow.followerId}`).emit('new_signal', {
        signal: {
          id: signal.id,
          symbol: signal.symbol,
          signalType: signal.signalType,
          price: signal.price,
          confidence: signal.confidence,
        },
        trader: follow.trader,
      });
    }

    console.log(`ğŸ“¡ Pushed signal ${signal.id} to ${followers.length} followers`);
  }
});

// æ¯å°æ—¶æ¸…ç†è¿‡æœŸä¿¡å·ï¼ˆ24å°æ—¶æœªæ‰§è¡Œï¼‰
cron.schedule('0 * * * *', async () => {
  const expiredCount = await prisma.binanceTradingSignal.updateMany({
    where: {
      status: 'PENDING',
      createdAt: {
        lt: new Date(Date.now() - 24 * 60 * 60 * 1000)  // 24 hours ago
      }
    },
    data: {
      status: 'EXPIRED'
    }
  });

  console.log(`ğŸ—‘ï¸  Expired ${expiredCount.count} old signals`);
});
```

**éªŒæ”¶æ ‡å‡†**:
- [ ] å®šæ—¶ä»»åŠ¡æ¯ 5 åˆ†é’Ÿæ­£å¸¸è¿è¡Œ
- [ ] ä¿¡å·æ¨é€ç»™æ­£ç¡®çš„å…³æ³¨è€…
- [ ] WebSocket æ¨é€å»¶è¿Ÿ < 1ç§’
- [ ] è¿‡æœŸä¿¡å·æ¸…ç†æ­£å¸¸

---

## Phase 4: è·Ÿä¹°å’Œäº¤æ˜“æ‰§è¡Œï¼ˆ8-10 å°æ—¶ï¼‰

### Task 4.1: è·Ÿä¹°é€»è¾‘å®ç°

**æ–‡ä»¶**: `src/services/copy-trading/copy-trading.service.ts`

**ä¸šåŠ¡é€»è¾‘**:
```typescript
export class CopyTradingService {
  async executeCopyTrade(
    followerId: string,
    signalId: string,
    mode: 'AUTO' | 'MANUAL'
  ): Promise<ExecutionResult> {
    // 1. è·å–ä¿¡å·
    const signal = await prisma.binanceTradingSignal.findUnique({
      where: { id: signalId },
      include: { tradingPair: true }
    });

    if (!signal || signal.status !== 'PENDING') {
      throw new Error('Signal not available for execution');
    }

    // 2. è·å–å…³æ³¨é…ç½®
    const follow = await prisma.follow.findFirst({
      where: {
        followerId,
        trader: {
          strategies: {
            some: {
              binanceSignals: {
                some: { id: signalId }
              }
            }
          }
        }
      }
    });

    if (!follow) {
      throw new Error('You are not following this trader');
    }

    const config = follow.config as CopyTradeConfig;

    // 3. é£æ§æ£€æŸ¥
    await this.performRiskChecks(followerId, signal, config);

    // 4. è®¡ç®—äº¤æ˜“æ•°é‡
    const quantity = await this.calculateTradeQuantity(followerId, signal, config);

    // 5. æ‰§è¡Œäº¤æ˜“
    if (mode === 'AUTO') {
      return await this.executeTradeAuto(followerId, signal, quantity);
    } else {
      // æ‰‹åŠ¨æ¨¡å¼ï¼šåªåˆ›å»ºå¾…ç¡®è®¤è®¢å•
      return await this.createPendingOrder(followerId, signal, quantity);
    }
  }

  private async performRiskChecks(
    userId: string,
    signal: BinanceTradingSignal,
    config: CopyTradeConfig
  ): Promise<void> {
    // æ£€æŸ¥ 1: è´¦æˆ·ä½™é¢
    const balances = await binanceService.getAccountBalance(userId);
    const usdtBalance = balances.find(b => b.asset === 'USDT');

    if (!usdtBalance || parseFloat(usdtBalance.free) < config.minBalance) {
      throw new Error('Insufficient balance');
    }

    // æ£€æŸ¥ 2: å•ç¬”é™é¢
    const orderValue = parseFloat(signal.price) * config.maxQuantity;
    if (orderValue > config.maxAmountPerTrade) {
      throw new Error(`Order value ${orderValue} exceeds max amount ${config.maxAmountPerTrade}`);
    }

    // æ£€æŸ¥ 3: äº¤æ˜“å¯¹è¿‡æ»¤
    if (config.symbolsFilter && !config.symbolsFilter.includes(signal.symbol)) {
      throw new Error(`Symbol ${signal.symbol} is not in your filter list`);
    }

    // æ£€æŸ¥ 4: æ¯æ—¥äºæŸç†”æ–­
    const todayLoss = await this.calculateTodayLoss(userId);
    if (todayLoss > config.maxDailyLoss) {
      throw new Error(`Daily loss limit reached: ${todayLoss}`);
    }
  }

  private async executeTradeAuto(
    userId: string,
    signal: BinanceTradingSignal,
    quantity: number
  ): Promise<ExecutionResult> {
    try {
      // è°ƒç”¨ Binance API ä¸‹å•
      const order = await binanceService.placeMarketOrder(userId, {
        symbol: signal.symbol,
        side: signal.signalType === 'BUY' ? 'BUY' : 'SELL',
        quantity,
      });

      // æ›´æ–°ä¿¡å·çŠ¶æ€
      await prisma.binanceTradingSignal.update({
        where: { id: signal.id },
        data: {
          status: 'EXECUTED',
          executedAt: new Date(),
          executedPrice: order.fills[0].price,
        }
      });

      // è®°å½•äº¤æ˜“
      await prisma.tradeSignal.create({
        data: {
          traderId: userId,
          exchange: 'binance',
          action: signal.signalType.toLowerCase(),
          symbol: signal.symbol,
          quantity,
          price: parseFloat(order.fills[0].price),
          reason: `Copy trade from signal ${signal.id}`,
        }
      });

      return {
        success: true,
        orderId: order.orderId,
        executedPrice: order.fills[0].price,
        executedQuantity: quantity,
      };
    } catch (error) {
      console.error('Execute trade error:', error);
      throw new Error(`Failed to execute trade: ${error.message}`);
    }
  }
}
```

**éªŒæ”¶æ ‡å‡†**:
- [ ] è‡ªåŠ¨è·Ÿå•æˆåŠŸæ‰§è¡Œ
- [ ] é£æ§æ£€æŸ¥æ­£å¸¸å·¥ä½œ
- [ ] äº¤æ˜“è®°å½•æ­£ç¡®ä¿å­˜
- [ ] ä½™é¢ä¸è¶³æ—¶æ‹’ç»äº¤æ˜“

---

## ä¸‹ä¸€æ­¥è¡ŒåŠ¨

ç°åœ¨å¼€å§‹å®æ–½ **Phase 2.1: Binance Service æ ¸å¿ƒå°è£…**ã€‚

éœ€è¦æˆ‘ç«‹å³å¼€å§‹å—ï¼Ÿ
